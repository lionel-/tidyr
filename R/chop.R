#' Chop and unchop
#'
#' @description
#' \Sexpr[results=rd, stage=render]{lifecycle::badge("maturing")}
#'
#' Chopping and unchopping preserve the width of a data frame, changing its
#' length. `chop()` makes `df` shorter by converting rows within each group
#' into list-columns. `unchop()` makes `df` longer by expanding list-columns
#' so that each element of the list-column gets its own row in the output.
#'
#' @details
#' Generally, unchopping is more useful than chopping because it simplifies
#' a complex data structure, and [nest()]ing is usually more appropriate
#' that `chop()`ing` since it better preserves the connections between
#' observations.
#'
#' @param data A data frame.
#' @param cols Column to chop or unchop (automatically quoted).
#'
#'   This should be a list-column containing generalised vectors (e.g.
#'   any mix of `NULL`s, atomic vector, S3 vectors, a lists, or data frames).
#' @param keep_empty By default, you get one row of output for each element
#'   of the list your unchopping/unnesting. This means that if there's a
#'   size-0 element (like `NULL` or an empty data frame), that entire row
#'   will be dropped from the output. If you want to preserve all rows,
#'   use `keep_empty = TRUE` to replace size-0 elements with a single row
#'   of missing values.
#' @param ptype Optionally, supply a data frame prototype for the output `cols`,
#'   overriding the default that will be guessed from the combination of
#'   individual values.
#' @export
#' @examples
#' # Chop ==============================================================
#' df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
#' # Note that we get one row of output for each unique combination of
#' # non-chopped variables
#' df %>% chop(c(y, z))
#' # cf nest
#' df %>% nest(data = c(y, z))
#'
#' # Unchop ============================================================
#' df <- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))
#' df %>% unchop(y)
#' df %>% unchop(y, keep_empty = TRUE)
#'
#' # Incompatible types -------------------------------------------------
#' # If the list-col contains types that can not be natively
#' df <- tibble(x = 1:2, y = list("1", 1:3))
#' try(df %>% unchop(y))
#' df %>% unchop(y, ptype = tibble(y = integer()))
#' df %>% unchop(y, ptype = tibble(y = character()))
#' df %>% unchop(y, ptype = tibble(y = list()))
#'
#' # Unchopping data frames -----------------------------------------------------
#' # Unchopping a list-col of data frames must generate a df-col because
#' # unchop leaves the column names unchanged
#' df <- tibble(x = 1:3, y = list(NULL, tibble(x = 1), tibble(y = 1:2)))
#' df %>% unchop(y)
#' df %>% unchop(y, keep_empty = TRUE)
chop <- function(data, cols) {
  if (missing(cols)) {
    return(data)
  }

  cols <- tidyselect::vars_select(tbl_vars(data), !!enquo(cols))

  vals <- data[cols]
  keys <- data[setdiff(names(data), cols)]
  split <- vec_split(vals, keys)

  vals <- map(split$val, ~ new_data_frame(map(.x, list), n = 1L))

  out <- vec_cbind(split$key, vec_rbind(!!!vals))
  reconstruct_tibble(data, out)
}

#' @export
#' @rdname chop
unchop <- function(data, cols, keep_empty = FALSE, ptype = NULL) {
  cols <- tidyselect::vars_select(tbl_vars(data), !!enquo(cols))
  if (length(cols) == 0) {
    return(data)
  }

  if (keep_empty) {
    for (col in cols) {
      data[[col]][] <- map(data[[col]], init_col)
    }
  }

  # In case `x` is a grouped data frame and any `cols` are lists,
  # in which case `[.grouped_df` will error
  cols <- new_data_frame(unclass(data)[cols])

  res <- vec_lengthen(cols, ptype)
  new_cols <- res$value
  slice_loc <- res$loc

  out <- vec_slice(data, slice_loc)

  out <- update_cols(out, new_cols)
  reconstruct_tibble(data, out)
}

# Helpers -----------------------------------------------------------------

vec_lengthen <- function(x, ptype = NULL) {
  n <- length(x)
  size <- vec_size(x)

  if (size == 0L) {
    cols <- map(x, vec_lengthen_ptype)
    out <- new_lengthen_df(integer(), cols, 0L, ptype)
    return(out)
  }

  empty <- int()

  if (length(x) > 1) {
    x <- transpose(x)

    # Use loops instead of map for efficiency because we're looping in
    # the direction of rows
    for (i in seq_along(x)) {
      row <- x[[i]]
      any_null <- FALSE
      all_null <- TRUE
      for (j in seq_along(row)) {
        if (is.null(row[[j]])) {
          row[[j]] <- NA
          any_null <- TRUE
        } else {
          all_null <- FALSE
        }
      }
      if (all_null) {
        empty <- c(empty, i)
      } else if (any_null) {
        x[[i]] <- row
      }
    }
    if (length(empty)) {
      x <- x[-empty]
    }

    x <- transpose(map(x, ~ vec_recycle_common(!!!.)))
  }

  if (!length(x)) {
    stop("internal error")
  }

  sizes <- map_int(x[[1]], vec_size)

  has_ptype <- !is.null(ptype)
  if (has_ptype && !is.data.frame(ptype)) {
    abort("`ptype` must be a data frame")
  }

  if (has_ptype) {
    cols <- map2(x, names(x), ~ {
      vec_c(!!!.x, .ptype = ptype[[.y]])
    })
  } else {
    cols <- map(x, ~ vec_c(!!!.))
  }

  out_size <- sum(sizes)
  seq_len_size <- seq_len(size)
  if (length(empty)) {
    seq_len_size <- seq_len_size[-empty]
  }
  loc <- rep(seq_len_size, sizes)

  new_lengthen_df(loc, cols, out_size, ptype)
}

new_lengthen_df <- function(loc, cols, n, ptype) {
  value <- new_data_frame(cols, n = n)

  if (!is.null(ptype)) {
    value <- vec_cast(value, ptype)
  }

  out <- list(loc = loc, value = value)
  new_data_frame(out, n = n)
}

vec_lengthen_ptype <- function(x) {
  # TODO: Update if `list_of()` ever explicitly inherits from `"list"`
  if (inherits(x, "list") || inherits(x, "vctrs_list_of")) {
    attr(x, "ptype") %||% unspecified(0L)
  } else {
    vec_ptype(x)
  }
}

finalise_size <- function(size) {
  if (is.na(size)) {
    0L
  } else {
    size
  }
}

tidyr_recycle <- function(x, size) {
  if (is.null(x)) {
    unspecified(size)
  } else {
    vec_recycle(x, size)
  }
}

update_size <- function(size, x) {
  size2(size, tidyr_size(x))
}

tidyr_size <- function(x) {
  if (is.null(x)) {
    NA_integer_
  } else {
    vec_size(x)
  }
}

size2 <- function(nx, ny) {
  if (is.na(nx)) {
    ny
  } else if (is.na(ny)) {
    nx
  } else if (nx == ny) {
    nx
  } else if (nx == 1L) {
    ny
  } else if (ny == 1L) {
    nx
  } else {
    abort(paste0("Incompatible lengths: ", nx, ", ", ny, "."))
  }
}

init_col <- function(x) {
  if (is_null(x)) {
    unspecified(1)
  } else if (vec_is_empty(x)) {
    vec_init(x, 1)
  } else {
    x
  }
}
